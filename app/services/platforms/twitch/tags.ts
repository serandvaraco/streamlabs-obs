import { Observable } from 'rxjs/Observable';
import { concatMap, expand, filter, map, toArray } from 'rxjs/operators';
import { empty } from 'rxjs/observable/empty';
import { ajax } from 'rxjs/observable/dom/ajax';
import { sortBy1 } from 'fp-ts/lib/Array';
import { compose } from 'fp-ts/lib/function';
import { fromNullable } from 'fp-ts/lib/Option';
import { contramap, ordString } from 'fp-ts/lib/Ord';
import { TwitchPagination } from './pagination';

/**
 * A tag on Twitch that could be assigned to a Stream.
 */
export type TwitchTag = {
  tag_id: string;
  /**
   * `true` if the tag is autogenerated.
   */
  is_auto: boolean;
  localization_names: {
    /**
     * Keys are locale names, in underscore (e.g. en-us). Values are the translations.
     */
    [x: string]: string;
  };
  localization_descriptions: {
    [x: string]: string;
  };
};

/**
 * TwitchTag with a label in the user's locale or en-US as fallback
 */
export type TwitchTagWithLabel = TwitchTag & { name: string };

/**
 * Response coming from Twitch from the Tags endpoint.
 */
type TwitchTagsResponse = {
  data: Array<TwitchTag>;
  pagination: TwitchPagination;
};

export interface TwitchRequestHeaders {
  Accept: 'application/vnd.twitchtv.v5+json';
  Authorization?: string;
  'Client-Id': string;
  'Content-Type': 'application/json';
}

/**
 * Intermediate representation of a Twitch tag response so
 * we can request subsequent pages of tags.
 */
interface PaginatedResponse {
  items: Array<TwitchTag>;
  cursor: string;
}

const requestTags = (
  headers: TwitchRequestHeaders,
  cursor: string
): Observable<PaginatedResponse> =>
  ajax
    .getJSON<TwitchTagsResponse>(
      `https://api.twitch.tv/helix/tags/streams?first=100&after=${cursor}`,
      headers
    )
    .pipe(
      map(response => ({
        cursor: response.pagination.cursor,
        items: response.data
      }))
    );

/**
 * Fetch all available tags that Twitch provides that are not
 * automatically generated. This will use the provided pagination
 * to request the whole dataset of tags.
 *
 * @param headers Headers including OAuth Token and App ID
 */
export const getAllTags = (
  headers: TwitchRequestHeaders
): Promise<Array<TwitchTag>> =>
  requestTags(headers, '')
    .pipe(
      expand(({ cursor }) => (cursor ? requestTags(headers, cursor) : empty())),
      concatMap(({ items }) => items),
      filter(tag => !tag.is_auto),
      toArray()
    )
    .toPromise();

const getLabelFor = (tag: TwitchTag, locale: string): string =>
  tag.localization_names[locale.toLowerCase()] ||
  tag.localization_names['en-us'];

const assignLabels = (locale: string) => (
  tags: Array<TwitchTag>
): Array<TwitchTagWithLabel> =>
  tags.map(tag => ({
    ...tag,
    name: getLabelFor(tag, locale)
  }));

const byName = contramap((tag: TwitchTagWithLabel) => tag.name, ordString);
const sortByName = sortBy1(byName, []);

export const prepareOptions = (
  locale: string,
  tags: Array<TwitchTag> | undefined
): Array<TwitchTagWithLabel> =>
  fromNullable(tags)
    .map(compose(sortByName, assignLabels(locale)))
    .getOrElse([]);

/**
 * Add a parameter, either "add" or "remove" with tag IDs separated by commas
 */
const addParam = (op: 'add' | 'remove', tags: Array<TwitchTagWithLabel>) => {
  if (!tags.length) {
    return {};
  }

  return { [op]: tags.map(tag => tag.tag_id).join(',') };
};

export const updateTags = (headers: TwitchRequestHeaders) => (
  tags: Array<TwitchTagWithLabel>
) => (streamId: string) => {
  const toAdd = tags;

  // TODO: how to track removals if we can't even get the active list w/o going live
  const toRemove: Array<TwitchTagWithLabel> = [];

  const params = {
    ...addParam('add', toAdd),
    ...addParam('remove', toRemove)
  };

  return ajax
    .put(
      `https://api.twitch.tv/helix/tags/streams?broadcaster_id=${streamId}`,
      JSON.stringify(params),
      headers
    )
    .toPromise();
};
